{"version":3,"file":"lrc-file-parser.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const timeFieldExp = /^(?:\\[[\\d:.]+\\])+/g\nexport const timeExp = /\\d{1,3}(:\\d{1,3}){0,2}(?:\\.\\d{1,3})/g\n\nexport const tagRegMap = {\n  title: 'ti',\n  artist: 'ar',\n  album: 'al',\n  offset: 'offset',\n  by: 'by',\n}\n\nexport type Lines = {\n  /**\n   * current line play time(ms)\n   */\n  time: number\n\n  /**\n   * current line lyric text\n   */\n  text: string\n\n  /**\n   * extended lyrics\n   */\n  extendedLyrics: string[]\n}\n\nexport type Options = {\n  /**\n   * Listening play event\n   * @param line line number of current play\n   * @param text lyric text of current play line\n   */\n  onPlay(line: number, text: string): void\n\n  /**\n   * listening lyrics seting event\n   * @param lines array of all lyric text\n   */\n  onSetLyric(lines: Lines[]): void\n\n  /**\n   * offset time(ms), default is 150 ms\n   */\n  offset?: number\n\n  /**\n   * playback rate, default is 1\n   */\n  playbackRate?: number\n\n  /**\n   * has remove blank line, default is true\n   */\n  isRemoveBlankLine?: boolean\n\n  /**\n   * lyric file text\n   */\n  lyric?: string\n\n  /**\n   * lyric translation file text\n   */\n  translationLyric?: string\n  \n  /**\n   * extended lyrics \n   */\n  extendedLyrics: string[]\n}\n\nexport type TT = {\n    invokeTime: number,\n    animationFrameId: number | null,\n    timeoutId: number | null,\n    callback: (() => void) | ((diff: number) => void),\n    thresholdTime: number,\n    run: () => void,\n    start: (callback: () => void, timeout: number) => void,\n    clear: () => void\n}\n\nexport const getNow = typeof performance == 'object' && performance.now ? performance.now.bind(performance) : Date.now.bind(Date)\n\nexport const timeoutTools: TT = {\n    invokeTime: 0,\n    animationFrameId: null,\n    timeoutId: null,\n    callback: () => {},\n    thresholdTime: 200,\n  \n    run() {\n      this.animationFrameId = window.requestAnimationFrame(() => {\n        this.animationFrameId = null\n        let diff = this.invokeTime - getNow()\n        // console.log('diff', diff)\n        if (diff > 0) {\n          if (diff < this.thresholdTime) return this.run()\n          return this.timeoutId = setTimeout(() => {\n            this.timeoutId = null\n            this.run()\n          }, diff - this.thresholdTime)\n        }\n  \n        // console.log('diff', diff)\n        this.callback(diff)\n      })\n    },\n    start(callback = () => { }, timeout = 0) {\n      // console.log(timeout)\n      this.callback = callback\n      this.invokeTime = getNow() + timeout\n  \n      this.run()\n    },\n    clear() {\n      if (this.animationFrameId) {\n        window.cancelAnimationFrame(this.animationFrameId)\n        this.animationFrameId = null\n      }\n      if (this.timeoutId) {\n        window.clearTimeout(this.timeoutId)\n        this.timeoutId = null\n      }\n    },\n}\n\nexport const t_rxp_1 = /^0+(\\d+)/\nexport const t_rxp_2 = /:0+(\\d+)/g\nexport const t_rxp_3 = /\\.0+(\\d+)/\nexport const formaterTimeLabel = (label: string) => {\n  return label.replace(t_rxp_1, '$1')\n    .replace(t_rxp_2, ':$1')\n    .replace(t_rxp_3, '.$1')\n}\n\nexport type LrcLinesMap = Record<string, Lines>\n\nexport const parseExtendedLyric = (lrcLinesMap: LrcLinesMap, extendedLyric: string) => {\n    const extendedLines = extendedLyric.split(/\\r\\n|\\n|\\r/)\n    for (let i = 0; i < extendedLines.length; i++) {\n      const line = extendedLines[i].trim()\n      let result = timeFieldExp.exec(line)\n      if (result) {\n        const timeField = result[0]\n        const text = line.replace(timeFieldExp, '').trim()\n        if (text) {\n          const times = timeField.match(timeExp)\n          if (times == null) continue\n          for (let time of times) {\n            const timeStr = formaterTimeLabel(time)\n            const targetLine = lrcLinesMap[timeStr]\n            if (targetLine) targetLine.extendedLyrics.push(text)\n          }\n        }\n      }\n    }\n  }\n  \nexport type Tags = {\n    title: string,\n    artist: string,\n    album: string,\n    offset: string | number,\n    by: string,\n  }\n  \nexport type AvailableTags = \"title\" | \"artist\" | \"album\" | \"offset\" | \"by\"\n\n","/*!\n * lrc-file-parser.js v2.3.2\n * Author: lyswhut\n * Github: https://github.com/lyswhut/lrc-file-parser\n * License: MIT\n */\n\nimport {\n  type Lines,\n  type Options,\n  type LrcLinesMap,\n  type Tags,\n  type AvailableTags,\n  getNow,\n  timeoutTools,\n  parseExtendedLyric,\n  tagRegMap,\n  timeFieldExp,\n  timeExp,\n  formaterTimeLabel\n} from './utils'\n\nexport default class Lyric {\n    lyric: string\n    extendedLyrics: string[]\n    tags: Tags\n    lines: Lines[]\n    onPlay: (line: number, text: string) => void\n    onSetLyric: (lines: Lines[]) => void\n    isPlay: boolean\n    curLineNum: number\n    maxLine: number\n    offset: number\n    _playbackRate: number\n    _performanceTime: number\n    _startTime: number\n    isRemoveBlankLine: boolean\n  constructor({ lyric = '', extendedLyrics = [], offset = 150, playbackRate = 1, onPlay = function() { }, onSetLyric = function() { }, isRemoveBlankLine = true } = {} as Options) {\n    this.lyric = lyric\n    this.extendedLyrics = extendedLyrics\n    this.tags = {\n      title: \"\",\n      artist: \"\",\n      album: \"\",\n      offset: \"\",\n      by: \"\"\n    }\n    this.lines = []\n    this.onPlay = onPlay\n    this.onSetLyric = onSetLyric\n    this.isPlay = false\n    this.curLineNum = 0\n    this.maxLine = 0\n    this.offset = offset\n    this._playbackRate = playbackRate\n    this._performanceTime = 0\n    this._startTime = 0\n    this.isRemoveBlankLine = isRemoveBlankLine\n    this._init()\n  }\n\n  _init() {\n    if (this.lyric == null) this.lyric = ''\n    if (this.extendedLyrics == null) this.extendedLyrics = []\n    this._initTag()\n    this._initLines()\n    this.onSetLyric(this.lines as Lines[])\n  }\n\n  _initTag() {\n    this.tags = {\n      title: \"\",\n      artist: \"\",\n      album: \"\",\n      offset: \"\",\n      by: \"\"\n    }\n    for (let tag in tagRegMap) {\n      const matches = this.lyric.match(new RegExp(`\\\\[${tagRegMap[tag as AvailableTags]}:([^\\\\]]*)]`, 'i'))\n      this.tags[tag as AvailableTags] = (matches && matches[1]) || ''\n    }\n    if (this.tags.offset) {\n      let offset = parseInt(this.tags.offset as string)\n      this.tags.offset = Number.isNaN(offset) ? 0 : offset\n    } else {\n      this.tags.offset = 0\n    }\n  }\n\n  _initLines() {\n    this.lines = []\n    const lines = this.lyric.split(/\\r\\n|\\n|\\r/)\n    const linesMap: LrcLinesMap = {}\n    const length = lines.length\n    for (let i = 0; i < length; i++) {\n      const line = lines[i].trim()\n      let result = timeFieldExp.exec(line)\n      if (result) {\n        const timeField = result[0]\n        const text = line.replace(timeFieldExp, '').trim()\n        if (text || !this.isRemoveBlankLine) {\n          const times = timeField.match(timeExp)\n          if (times == null) continue\n          for (let time of times) {\n            const timeStr = formaterTimeLabel(time)\n            if (linesMap[timeStr]) {\n              linesMap[timeStr].extendedLyrics.push(text)\n              continue\n            }\n            const timeArr = timeStr.split(':')\n            if (timeArr.length > 3) continue\n            else if (timeArr.length < 3) for (let i = 3 - timeArr.length; i--;) timeArr.unshift('0')\n            if (timeArr[2].indexOf('.') > -1) timeArr.splice(2, 1, ...timeArr[2].split('.'))\n\n            linesMap[timeStr] = {\n              time: parseInt(timeArr[0]) * 60 * 60 * 1000 + parseInt(timeArr[1]) * 60 * 1000 + parseInt(timeArr[2]) * 1000 + parseInt(timeArr[3] || \"0\"),\n              text,\n              extendedLyrics: [],\n            }\n          }\n        }\n      }\n    }\n\n    for (const lrc of this.extendedLyrics) parseExtendedLyric(linesMap, lrc)\n    this.lines = Object.values(linesMap)\n    this.lines.sort((a, b) => {\n      return a.time - b.time\n    })\n    this.maxLine = this.lines.length - 1\n  }\n\n  _currentTime() {\n    return (getNow() - this._performanceTime) * this._playbackRate + this._startTime\n  }\n\n  _findCurLineNum(curTime: number, startIndex = 0) {\n    if (curTime <= 0) return 0\n    const length = this.lines?.length || 0\n    for (let index = startIndex; index < length; index++) if (curTime <= this.lines[index].time) return index === 0 ? 0 : index - 1\n    return length - 1\n  }\n\n  _handleMaxLine() {\n    this.onPlay(this.curLineNum, this.lines[this.curLineNum].text)\n    this.pause()\n  }\n\n  _refresh() {\n    this.curLineNum++\n    // console.log('curLineNum time', this.lines[this.curLineNum].time)\n    if (this.curLineNum >= this.maxLine) return this._handleMaxLine()\n\n    let curLine = this.lines[this.curLineNum]\n\n    const currentTime = this._currentTime()\n    const driftTime = currentTime - curLine.time\n\n    if (driftTime >= 0 || this.curLineNum === 0) {\n      let nextLine = this.lines[this.curLineNum + 1]\n      const delay = (nextLine.time - curLine.time - driftTime) / this._playbackRate\n\n      if (delay > 0) {\n        if (this.isPlay) {\n          timeoutTools.start(() => {\n            if (!this.isPlay) return\n            this._refresh()\n          }, delay)\n        }\n        this.onPlay(this.curLineNum, curLine.text)\n      } else {\n        let newCurLineNum = this._findCurLineNum(currentTime, this.curLineNum + 1)\n        if (newCurLineNum > this.curLineNum) this.curLineNum = newCurLineNum - 1\n        this._refresh()\n      }\n      return\n    }\n\n    this.curLineNum = this._findCurLineNum(currentTime, this.curLineNum) - 1\n    this._refresh()\n  }\n  \n  /**\n   * Play lyric\n   * @param time play time, unit: ms\n   */\n  play(curTime = 0) {\n    if (!this.lines.length) return\n    this.pause()\n    this.isPlay = true\n\n    this._performanceTime = getNow() - parseInt((this.tags.offset as number + this.offset).toString())\n    this._startTime = curTime\n    // this._offset = this.tags.offset + this.offset\n\n    this.curLineNum = this._findCurLineNum(this._currentTime()) - 1\n\n    this._refresh()\n  }\n\n  /**\n   * Pause lyric\n   */\n  pause() {\n    if (!this.isPlay) return\n    this.isPlay = false\n    timeoutTools.clear()\n    if (this.curLineNum === this.maxLine) return\n    const curLineNum = this._findCurLineNum(this._currentTime())\n    if (this.curLineNum !== curLineNum) {\n      this.curLineNum = curLineNum\n      this.onPlay(curLineNum, this.lines[curLineNum].text)\n    }\n  }\n\n  /**\n   * Set playback rate\n   * @param playbackRate playback rate\n   */\n  setPlaybackRate(playbackRate: number) {\n    this._playbackRate = playbackRate\n    if (!this.lines.length) return\n    if (!this.isPlay) return\n    this.play(this._currentTime())\n  }\n  \n  /**\n   * Set lyric\n   * @param lyricStr lyric file text\n   * @param extendedLyricStrs extended lyric file text array, for example lyric translations\n   */\n  setLyric(lyric: string, extendedLyrics: string[]=[]) {\n    // console.log(extendedLyrics)\n    if (this.isPlay) this.pause()\n    this.lyric = lyric\n    this.extendedLyrics = extendedLyrics\n    this._init()\n  }\n}\n"],"names":["timeFieldExp","timeExp","tagRegMap","title","artist","album","offset","by","getNow","performance","now","bind","Date","timeoutTools","invokeTime","animationFrameId","timeoutId","callback","thresholdTime","run","this","window","requestAnimationFrame","diff","setTimeout","start","timeout","clear","cancelAnimationFrame","clearTimeout","t_rxp_1","t_rxp_2","t_rxp_3","formaterTimeLabel","label","replace","parseExtendedLyric","lrcLinesMap","extendedLyric","extendedLines","split","i","length","line","trim","result","exec","timeField","text","times","match","time","targetLine","extendedLyrics","push","constructor","lyric","playbackRate","onPlay","onSetLyric","isRemoveBlankLine","tags","lines","isPlay","curLineNum","maxLine","_playbackRate","_performanceTime","_startTime","_init","_initTag","_initLines","tag","matches","RegExp","parseInt","Number","isNaN","linesMap","timeStr","timeArr","unshift","indexOf","splice","lrc","Object","values","sort","a","b","_currentTime","_findCurLineNum","curTime","startIndex","_a","index","_handleMaxLine","pause","_refresh","curLine","currentTime","driftTime","delay","newCurLineNum","play","toString","setPlaybackRate","setLyric"],"mappings":"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"}